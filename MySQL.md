# MySQL

## 资料来源

> [MySQL教程：MySQL数据库学习宝典（从入门到精通） (biancheng.net)](http://c.biancheng.net/mysql/)
>
> [MySQL 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql-tutorial.html)
>
> [MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.337.search-card.all.click)

## 索引

> [【大厂面试】MySQL索引，给我整不会了！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KP4y1A7QB?spm_id_from=333.337.search-card.all.click)

​	索引类似书本的目录，是存储引擎用于提高数据库表的访问速度的一种数据结构。

​	索引实际上也是一张表，这张表保存了主键与索引字段，并指向实体表的记录。

​	索引会降低更新表的速度。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。

​	不同存储引擎下的索引实现细节不同。

### 工作原理

​	数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。

​	进行数据查找时，首先看查询条件是否命中某一条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描。

### 设计原则

1. 使用区分度高的字段作为索引，索引的效果更好。
2. 尽量使用短索引，较小的索引涉及到的磁盘I/O较少。查询的速度更快。
3. 索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。
4. 利用最左前缀原则。

### 优点

1. 提高数据检索效率，降低数据库I/O成本。
2. 通过创建唯一索引，可以保证数据库表中每一行的唯一性。列在添加唯一约束时会默认创建唯一索引。
3. 实现数据库的参考完整性方面。可以实现加速表和表之间的连接。对于有依赖关系的父子表，可以提高查询速度。
4. 使用分组和排序子句进行查询时，可以显著减少查询中分组和排序的时间

### 缺点

1. 创建和维护索引需要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
2. 索引占据磁盘空间。
3. 提高了查询速度，但降低了更新表的速度。当对表中的数据进行增删改时，索引也需要动态维护。

### 最左前缀原则

​	若SQL语句中使用了组合索引中的最左边的索引，那么这条SQL语句就可以利用这个组合索引去进行匹配。

​	当遇到范围查询时就会停止匹配，后面的字段不会用到索引。

### 分类

#### 数据结构角度

##### B+tree索引

​	MySQL使用的最多的索引类型。底层基于B+树实现。

* 性能相对稳定，每次查询都是从根节点到叶子节点

##### 全文(FULLTEXT)索引

​	目前只有MyISAM引擎支持。只有CHAR、VARCHAR、TEXT列上可以创建全文索引。

##### 哈希索引

​	基于哈希表实现，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值时不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。

* 不支持排序，哈希表是无序的
* 不支持范围查找。
* 不支持模糊查询以及多列索引的最左前缀匹配
* 性能不稳定，哈希表中会存在哈希冲突

##### R-tree索引

​	仅支持geometry数据类型。其优势在于范围查找。

#### 物理存储角度

> [聚簇索引和非聚簇索引的关系 - 小学生很小 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wsming/p/13864292.html)

##### 聚簇索引

​	将数据存储与索引放到了一块，索引结构的子节点保存了行数据。

##### 非聚簇索引

​	将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。

#### 逻辑角度

##### 前缀索引

​	对文本或字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

​	可以避免很长的字符列创造的索引特别大而且慢。

​	关键在于选择足够长的前缀以保证较高的索引选择性。选择性高的索引可以让MySQL在查找是过滤掉更多的数据。

##### 多列索引

##### 空间索引

##### 普通索引

##### 唯一索引

##### 主键索引

### 覆盖索引

​	select的数据列只用从索引中就能够取得，不需要回表进行二次查询，也就是说查询列要被所使用的索引覆盖。

​	对于InnoDB表的二级索引，如果索引能够覆盖查询的列，那么就可以避免对主键索引的二次查询。

​	不是所有类型的索引都能成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引，全文索引不存储索引列的值，所以只有B+树索引可以用作覆盖索引。

### 索引失效

1. 对于组合索引，不是使用组合索引最左边的字段，则不会使用索引。
2. 以%开头的like查询。
3. 查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，导致索引失效。
4. 判断索引列是否不等于某个值时
5. 对索引列进行运算
6. 查询条件使用`or`连接

## 事务

​	事务是逻辑上的一组数据库操作，要么都执行，要么都不执行。

### 特性（ACID）

#### 原子性（Atomicity）

​	事务是一个完整的操作，事务的各元素是不可分的。事务中的所有元素必须作为一个整体提交或回滚，如果事务中的任何元素失败，则整个事务失败。

#### 一致性（Consistency）

​	事务完成时，数据必须处于一致状态。

​	事务开始前，数据库中存储的数据处于一致状态。正在进行中的事务，数据可能处于不一致的状态，当事务成功完成后，数据必须再次回到一致状态。

#### 隔离性（Isolation）

​	对数据进行修改的所有并发事务是彼此隔离，这表明事务必须是独立的，它不应以任何方式依赖或影响其他事务。修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束后在访问这些数据。

#### 持久性（Durability）

​	一个事务被提交之后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 事务之间的相互影响

#### 脏读

​	一个事务还未提交数据时，另一个事务读取了数据。

#### 幻读

​	同一个事务中，同一个查询多次返回的结果不一致。

#### 不可重复读

​	同一个事务在整个事务过程中对同一比数据进行读取，每次读取结果都不同。

#### 丢失更新

* 第一类丢失更新：撤销一个事务的时候，把其他事务应提交的更新数据覆盖了。这是完全没有事务隔离级别造成的。
* 当两个或多个事务查询相同的记录，然后各自基于查询的结果更新记录时会造成第二类丢失更新。每个事物不知道其他事务的的存在，最后一个事务对记录所作的更改将覆盖其他事务之前对该纪录所作的更改。

### 共享锁和排他锁

* 共享锁：被一个事务加上共享锁的数据可以被其他事务读取，但不能修改。
* 排他锁：被一个事务加上排他锁的数据不能被其他事务读取或修改。

### 隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 读未提交 |  Y   |     Y      |  Y   |
| 读已提交 |  -   |     Y      |  Y   |
| 可重复读 |  -   |     -      |  Y   |
| 可序列化 |  -   |     -      |  -   |

####  读未提交

​	最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的事务问题都会发生。

​	原理：

* 事务对当前读取的数据不加锁。
* 事务对数据更新前添加行级共享锁，直到事务结束才释放。

#### 读已提交

​	只有在事务提交后，其更新结果才会被其他事务看见，可以解决脏读问题。

​	原理：

* 事务对当前被读取的数据加上行级共享锁，一旦读完该行，立即释放该行级共享锁。
* 事务在更新数据的瞬间，必须先对其加行级排他锁，直到事务结束后才释放。

#### 可重复读

​	在一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他的事务对这份数据进行操作，以及这个事务是否提交。

​	原理：

* 事务读取数据瞬间对数据加上行级共享锁，事务结束时释放。
* 事务修改数据瞬间对数据加上行级排他锁，事务结束时释放。

#### 可串行化

​	事务串行化执行，牺牲了并发性，隔离级别最高。

